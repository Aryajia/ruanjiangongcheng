## 为什么要进行单元测试
1.单元测试不但会使你的工作完成得更轻松。而且会令我们的设计会变得更好，甚至大大减少你花在调试上面的时间 2.提高代码质量 3.


减少bug，快速定位bug。
可以验证单元代码和详细设计文档的一致性，跟踪详细设计文档中设计的实现，发现详细设计文档中存在的错误;发现在编码过程中引入的错误编码过程中引入的错误包含两类:和设计不符引入的错误;和设计相符但由于编码出现疏漏导致错误。
## java,冒泡排序
```
	public class MaoPao {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[]a= {1,32,12,3,5,66,42,0};
		for(int i=0;i<a.length-1;i++) {
			for(int j=0;j<a.length-1-i;j++) {
				if(a[j]<a[j+1]) {
					int t=a[j];
					a[j]=a[j+1];
					a[j+1]=t;
		}
        }
    }
		for(int i=0;i<a.length ;i++) {
	System.out.print(a[i]+" ");}  
```
#### 进行单元测试
一：





3.1语句覆盖
测试用例 I=0,j=0 测试输入 1,4,3,2,5,7,6,8,9,11 覆盖对象 1,2,4,5,6,3,7 测试结果 1,2,3,4,5，6,7,8,9,11 
3.2判定覆盖
测试用例 I=0,j=0 测试输入 1,4,3,2,5,7,6,8,9,11 覆盖对象 1,2,6,7,8,9,4,5,3 测试结果 1,2,3,4,5，6,7,8,9,11 3.3
条件覆盖
测试用例 I=0,j=0 测试输入 1,4,3,2,5,7,6,8,9,11 覆盖对象 1,2,6,7,8,9,4,5,3 测试结果 1,2,3,4,5，6,7,8,9,11 3.4
路径覆盖
测试用例 I=0,j=0 测试输入 1,4,3,2,5,7,6,8,9,11 覆盖对象 1,2,6,7,8,9,4,5,3 测试结果 1,2,3,4,5，6,7,8,9,11


